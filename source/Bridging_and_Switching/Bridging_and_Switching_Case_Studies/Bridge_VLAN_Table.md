# 概述

___

从RouterOS v6.41开始，可以使用网桥来过滤网络中的VLAN。为了达到这个目的，应该使用[网桥VLAN过滤](https://help.mikrotik.com/docs/display/ROS/Bridging+and+Switching#BridgingandSwitching-BridgeVLANFiltering)功能。这个功能应该用来代替许多已知的VLAN错误配置，这些错误配置很可能导致你的性能问题或连接问题，你可以在[VLAN in a bridge with a physical interface](https://help.mikrotik.com/docs/display/ROS/Layer2+misconfiguration#Layer2misconfiguration-VLANinabridgewithaphysicalinterface)部分阅读最受欢迎的错误配置之一。网桥 VLAN 过滤功能最重要的部分是网桥 VLAN 表，它规定了每个端口允许哪些 VLAN，但如果你想进行更高级的设置，配置它可能会变得相当复杂，对于一般的设置，你可以使用 [Trunk and Access ports](https://help. mikrotik.com/docs/display/ROS/Bridging+and+Switching#BridgingandSwitching-VLANExample-TrunkandAccessPorts）的例子，但本指南的目的是深入解释并指出使用网桥VLAN过滤时的一些行为特征。

# 背景

___

在深入解释桥接VLAN过滤之前， 应该了解桥接VLAN过滤所涉及的几个基本概念。

- **Tagged/Untagged** 在"/interface bridge vlan "菜单下，你可以指定一个包含有标签和无标签端口的项。一般来说，有标签的端口应该是您的聚合端口，无标签的端口应该是您的接入端口。通过指定一个有标签的端口，网桥将始终为通过该端口发送的数据包设置一个 VLAN 标签 (出站)。如果指定了一个未标记的端口， 网桥将总是从出站数据包中去除 VLAN 标记。
- **VLAN-ids** - 在"/interface bridge vlan "菜单下，您可以指定一项，其中允许在特定的端口上使用某些VLAN。VLAN ID在出站端口上被检查。如果数据包中的 VLAN ID 不存在于出站端口的桥接 VLAN 表中，那么数据包在发送之前就会被丢弃。
- **PVID** - 端口VLAN ID用于接入端口，用一个特定的VLAN ID来标记所有入站流量。每使用一个PVID，就会在网桥VLAN表中添加一个动态条目，该端口会被自动添加为未标记的端口。
- **Ingress filtering/** - 默认情况下，在桥接VLAN表中不存在的VLAN会在发送前被丢弃（出站），但这个属性允许你在接收数据包时丢弃（入站）。
- **管理访问** - 网桥应该只是在网桥端口之间转发数据包，在其他设备看来，它们之间只是有一条线。通过网桥VLAN过滤，你可以限制哪些数据包被允许访问配置了网桥的设备，最常见的做法是只允许使用一个非常具体的VLAN ID来访问设备，但也有其他方法可以授予设备访问权。在通过网桥端口访问设备时，管理访问是增加另一层安全性的好方法，这种访问方式有时被称为管理端口。对于支持 [VLAN Filtering with hardware offloading] (https://help.mikrotik.com/docs/display/ROS/Bridging+and+Switching#BridgingandSwitching-BridgeHardwareOffloading) 的设备，它也与网桥的CPU端口有关。
- **CPU端口** -- 每个带有交换芯片的设备都有一个特殊用途的端口，称为CPU端口，它用于与设备的CPU通信。对于支持硬件卸载的VLAN过滤的设备，这个端口就是网桥接口本身。这个端口主要用于创建管理访问，但也可用于其他目的，例如，在VLAN之间路由流量，标记数据包和应用队列。
- **frame-type** - 你可以过滤掉数据包，无论它们是否有VLAN标签，这对于为你的桥接端口增加一层安全保障很有用。
- **EtherType\** - 默认情况下，VLAN感知网桥会通过检查C-TAG（0x8100）来过滤VLAN，所有其他的VLAN标签都被认为是无标签的数据包（没有VLAN标签）。所选的 EtherType 将被用于 VLAN 过滤和 VLAN 标记/未标记。
- 如果数据包的 EtherType 与网桥配置的 EtherType 不匹配，那么入站数据包就会被视为无标记数据包，这种行为为将 VLAN 封装到另一个不同的 VLAN 提供了可能性。这也为通过网络中的不同设备来分流特定的流量提供了可能。
- 如果一个数据包有一个与EtherType相匹配的VLAN标签，那么这个数据包就会被认为是一个有标签的数据包，但是你可以强迫另一个VLAN标签，而不管数据包的内容。通过在网桥端口上设置 `tag-stacking=yes`，您将在所有入站数据包的任何其他标签之上添加另一个具有 PVID 值的 VLAN 标签。

# 聚合/接入端口设置

___

下面你可以看到一个很常见的图，是由一个聚合端口和多个接入端口组成的非常典型的设置类型。

![](https://help.mikrotik.com/docs/download/attachments/28606465/Trunk_access_setup.png?version=2&modificationDate=1618317157478&api=v2)

这种设置非常普遍，它提供了将你的网络划分为多个网段的可能性，同时使用一个交换机和一个路由器，这样的要求对于想要分离多个部门的公司非常普遍。有了VLAN，你可以使用不同的DHCP服务器，它可以根据VLAN ID从不同的子网发出一个IP地址，这使得创建防火墙规则和QoS更加容易。

在这样的设置中，你会把一些通用设备如台式电脑连接到**ether2**和**ether3**，这些设备可以被认为是工作站，它们一般只使用无标签的流量（有可能对所有发送出通用工作站的流量强制使用VLAN标签，尽管这不是很常见）。为了将一些工作站与其他工作站隔离开来，你必须给所有进入**ether2**或**ether3**的数据包添加一个VLAN标签，但要决定数据包应该得到什么VLAN ID，就要用一个叫做**基于端口的VLAN**概念。在这个概念中，数据包得到一个VLAN标签，其VLAN ID基于设备所连接的桥接端口。例如，在这个设置中，**ether2**的设备将得到一个带有**VLAN20**的VLAN标签，而**ether3**的设备将得到一个带有**VLAN30**的VLAN标签，只要你有足够的桥接端口，这个概念是非常可扩展的。这应该让你明白，网桥和**ether2/ether3**后面的设备之间的通信是没有标签的（因为没有VLAN标签，所以叫这个名字）。

当我们确定了我们的非标记端口后，我们现在可以确定我们的标记端口。标签端口将是聚合端口（携带多个VLAN的端口），通常这个端口连接到路由器或另一个交换机/网桥，你也可以有多个聚合端口。标签端口总是携带带有VLAN标签的数据包（因此而得名），你必须**总是**为你希望这个端口转发的每个VLAN ID指定标签端口。有可能一个端口是一个VLAN ID的标记端口，而同一个端口是一个不同VLAN ID的非标记端口，但这是针对不同类型的设置（混合端口设置）。

必须为PVID属性添加特别说明。这个属性应该用于接入端口，但它也可以用于聚合端口（在混合端口设置中）。通过使用 PVID 属性，您将为该特定网桥端口上收到的所有 **UNTAGGED** 数据包添加一个新的 VLAN 标签，其 VLAN ID 在 PVID 中指定。PVID 对有标签的数据包没有任何影响，这意味着，例如，如果在 **ether2** 上收到一个 VLAN 标签为 **VLAN40** 的数据包，而这个数据包有 `PVID=20`，那么 VLAN 标签就不会被改变，转发将取决于网桥 VLAN 表中的条目。

要配置聚合/接入端口设置，首先需要创建一个网桥。

<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container" title="Hint: double-click to select code"><div class="line number1 index0 alt2" data-bidi-marker="true"><code class="ros constants">/interface bridge</code></div><div class="line number2 index1 alt1" data-bidi-marker="true"><code class="ros functions">add </code><code class="ros value">name</code><code class="ros plain">=bridge1</code></div></div></td></tr></tbody></table>

先不要启用VLAN过滤，因为你可能会因为没有管理权限而被锁定在设备之外，管理权限是在最后配置的。

添加桥接端口，为每个接入端口指定PVID。

<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container" title="Hint: double-click to select code"><div class="line number1 index0 alt2" data-bidi-marker="true"><code class="ros constants">/interface bridge port</code></div><div class="line number2 index1 alt1" data-bidi-marker="true"><code class="ros functions">add </code><code class="ros value">bridge</code><code class="ros plain">=bridge1</code> <code class="ros value">interface</code><code class="ros plain">=ether1</code></div><div class="line number3 index2 alt2" data-bidi-marker="true"><code class="ros functions">add </code><code class="ros value">bridge</code><code class="ros plain">=bridge1</code> <code class="ros value">interface</code><code class="ros plain">=ether2</code> <code class="ros value">pvid</code><code class="ros plain">=20</code></div><div class="line number4 index3 alt1" data-bidi-marker="true"><code class="ros functions">add </code><code class="ros value">bridge</code><code class="ros plain">=bridge1</code> <code class="ros value">interface</code><code class="ros plain">=ether3</code> <code class="ros value">pvid</code><code class="ros plain">=30</code></div></div></td></tr></tbody></table>

PVID 在启用 VLAN 过滤之前没有任何作用。

在网桥 VLAN 表中添加适当的条目。

<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container" title="Hint: double-click to select code"><div class="line number1 index0 alt2" data-bidi-marker="true"><code class="ros constants">/interface bridge vlan</code></div><div class="line number2 index1 alt1" data-bidi-marker="true"><code class="ros functions">add </code><code class="ros value">bridge</code><code class="ros plain">=bridge1</code> <code class="ros value">tagged</code><code class="ros plain">=ether1</code> <code class="ros value">untagged</code><code class="ros plain">=ether2</code> <code class="ros value">vlan-ids</code><code class="ros plain">=20</code></div><div class="line number3 index2 alt2" data-bidi-marker="true"><code class="ros functions">add </code><code class="ros value">bridge</code><code class="ros plain">=bridge1</code> <code class="ros value">tagged</code><code class="ros plain">=ether1</code> <code class="ros value">untagged</code><code class="ros plain">=ether3</code> <code class="ros value">vlan-ids</code><code class="ros plain">=30</code></div></div></td></tr></tbody></table>

你可能会想用一个项来简化这个项，类似于这样。

<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container" title="Hint: double-click to select code"><div class="line number1 index0 alt2" data-bidi-marker="true"><code class="ros constants">/interface bridge vlan</code></div><div class="line number2 index1 alt1" data-bidi-marker="true"><code class="ros functions">add </code><code class="ros value">bridge</code><code class="ros plain">=bridge1</code> <code class="ros value">tagged</code><code class="ros plain">=ether1</code> <code class="ros value">untagged</code><code class="ros plain">=ether2,ether3</code> <code class="ros value">vlan-ids</code><code class="ros plain">=20,30</code></div></div></td></tr></tbody></table>

不要在接入端口上使用多个VLAN ID。这将无意中在两个接入端口上同时允许**VLAN20**和**VLAN30**。在上面的例子中，**ether3**应该为所有进入的数据包设置VLAN标签，使用**VLAN30**(因为`PVID=30`)，但当VLAN通过这个端口发送出去时，没有限制这个端口上允许的VLAN。网桥 VLAN 表负责决定是否允许某个 VLAN 通过特定端口发送。上面的条目指定了**VLAN20**和**VLAN30**都允许通过**ether2**和**ether3**发送出去，在此基础上，该项还指定了数据包应该在没有VLAN标签的情况下发送出去（数据包作为无标签的数据包发送）。因此，你可能会从VLAN向不应该接收这种流量的端口泄漏数据包，请看下面的图片。

![](https://help.mikrotik.com/docs/download/attachments/28606465/Trunk_access_setup_bad.png?version=2&modificationDate=1618317557770&api=v2)

错误配置的 VLAN 表允许 VLAN20 通过 ether3 发送，它也会允许 VLAN30 通过 ether2。

不要为接入端口使用一个以上的桥接VLAN表项中指定的VLAN ID， 只应该为聚合端口指定多个VLAN ID。

没有必要把桥接端口作为无标记端口添加，因为每个桥接端口都是作为无标记端口动态添加的，其 VLAN ID 是在 PVID 属性中指定的。这是因为有一个功能可以自动在网桥 VLAN 表中添加一个适当的条目， 以方便和提高性能， 但这个功能也有一些注意事项， 您必须加以注意。所有具有相同PVID的端口都会被添加到一个适当的VLAN ID条目中，作为无标记的端口，但请注意**网桥接口**也有一个VLAN ID。

出于测试目的，我们将启用 VLAN 过滤，但请注意，这可能会失去对设备的访问，因为它还没有配置管理权限（我们将在后面配置）。建议在使用串行控制台时配置VLAN过滤，尽管你也可以通过一个没有加入网桥的端口来配置设备。确保你使用的是串行控制台或通过不同的端口（不在网桥中）连接，并启用VLAN过滤功能。

<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container" title="Hint: double-click to select code"><div class="line number1 index0 alt2" data-bidi-marker="true"><code class="ros constants">/interface bridge </code><code class="ros functions">set </code><code class="ros plain">bridge1 </code><code class="ros value">vlan-filtering</code><code class="ros plain">=yes</code></div></div></td></tr></tbody></table>
  
可能不会在启用VLAN过滤后就失去对设备的访问，但你可能会被断开连接，因为网桥必须自我重置才能使VLAN过滤生效，这将迫使你重新连接（这主要与使用MAC-telnet时有关）。你有可能使用无标记的流量来访问你的设备，这种情况将在下面描述。

如果你现在启用了VLAN过滤，并打印出当前的VLAN表，你会看到这样一张表。

<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container" title="Hint: double-click to select code"><div class="line number1 index0 alt2" data-bidi-marker="true"><code class="text plain">[admin@MikroTik] &gt; /interface bridge vlan print</code></div><div class="line number2 index1 alt1" data-bidi-marker="true"><code class="text plain">Flags: X - disabled, D - dynamic</code></div><div class="line number3 index2 alt2" data-bidi-marker="true"><code class="text spaces">&nbsp;</code><code class="text plain">#&nbsp;&nbsp; BRIDGE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VLAN-IDS&nbsp; CURRENT-TAGGED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CURRENT-UNTAGGED</code></div><div class="line number4 index3 alt1" data-bidi-marker="true"><code class="text spaces">&nbsp;</code><code class="text plain">0&nbsp;&nbsp; bridge1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ether1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ether2</code></div><div class="line number5 index4 alt2" data-bidi-marker="true"><code class="text spaces">&nbsp;</code><code class="text plain">1&nbsp;&nbsp; bridge1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ether1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ether3</code></div><div class="line number6 index5 alt1" data-bidi-marker="true"><code class="text spaces">&nbsp;</code><code class="text plain">2 D bridge1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bridge1</code></div><div class="line number7 index6 alt2" data-bidi-marker="true"><code class="text spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="text plain">ether1</code></div></div></td></tr></tbody></table>

由于所有桥接端口（包括聚合端口，**ether1**）都默认设置了 "PVID=1"，所以**VLAN1**有一个动态添加的项，但你也应该注意到，**bridge1**接口（CPU端口）也被动态添加。你应该注意到，**bridge1**也是一个网桥端口，因此可能会被动态添加到网桥VLAN表中。你有可能因为这个功能而无意中允许对设备的访问。例如，如果您按照本指南的要求，为聚合端口（**ether1**）设置了**PVID=1**，而没有同时改变CPU端口（**bridge1**）的PVID，那么通过**ether1**使用无标记流量访问设备是允许的，这在打印出网桥VLAN表时也可以看到。这种情况在下面的图片中有所说明。

![](https://help.mikrotik.com/docs/download/attachments/28606465/Trunk_access_setup_unintentional_mgmt.png?version=2&modificationDate=1618317673875&api=v2)

无意中允许通过聚合端口使用未标记的流量进行管理访问

经常检查网桥VLAN表，是否无意中允许某些VLAN或无标记流量进入特定端口，特别是CPU端口（网桥）。

有一个简单的方法可以防止网桥（CPU端口）被添加为无标记端口，你可以简单地将聚合端口的PVID设置为与网桥的PVID不同（或改变网桥的PVID），但还有一个选择更直观，也更值得推荐。既然你期望聚合端口只应该接收有标记的流量（在这个例子中，它应该只接收**VLAN20/VLAN30**），而不接收无标记的流量，那么你可以使用ingress-filtering和frame-type来过滤掉不需要的数据包，为了充分理解ingress filtering的行为，我们必须首先了解管理访问的细节。

管理访问是用来创建一种通过启用了 VLAN 过滤的网桥访问设备的方式。你可以简单地允许无标记的访问，要做到这一点相当简单。假设你想让**ether3**后面的工作站能够访问设备，我们之前假设工作站是一台普通的计算机，不会使用有标签的数据包，因此只会发送无标签的数据包，这意味着我们应该把CPU端口（**bridge1**）作为一个无标签的接口添加到网桥的VLAN表中，要做到这一点，只需对**bridge1**和**ether3**端口使用相同的PVID值，把两个端口设置为VLAN ID无标签的成员。 在本例中，你将从**ether3**连接，它有`PVID=30`，所以你要相应地改变配置。

<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container" title="Hint: double-click to select code"><div class="line number1 index0 alt2" data-bidi-marker="true"><code class="ros constants">/interface bridge </code><code class="ros functions">set </code><code class="ros plain">[</code><code class="ros functions">find </code><code class="ros value">name</code><code class="ros plain">=bridge1]</code> <code class="ros value">pvid</code><code class="ros plain">=30</code></div><div class="line number2 index1 alt1" data-bidi-marker="true"><code class="ros constants">/interface bridge vlan </code><code class="ros functions">set </code><code class="ros plain">[</code><code class="ros functions">find </code><code class="ros value">vlan-ids</code><code class="ros plain">=30]</code> <code class="ros value">untagged</code><code class="ros plain">=bridge1,ether3</code></div></div></td></tr></tbody></table>

可以使用动态添加具有相同PVID值的无标记端口的功能，你可以简单地改变PVID以匹配**ether3**和**bridge1**。

允许使用无标记流量访问设备并不是一个好的安全做法，一个更好的方法是允许使用一个非常具体的VLAN（有时称为管理VLAN）来访问设备，在我们的案例中，这将是**VLAN99**。这增加了一个重要的安全层，因为攻击者必须猜测用于管理的VLAN ID，然后猜测登录凭证，在此基础上，你甚至可以通过只允许使用某些IP地址访问设备来增加另一个安全层。本指南的目的是提供一个深入的解释，为此，我们在设置中增加了一个复杂程度，以了解一些你必须考虑到的可能的注意事项。我们将允许从一个访问端口使用标记流量进行访问（如下图所示）。为了允许使用**VLAN99**从**ether3**访问设备，我们必须在网桥VLAN表中添加一个适当的条目。此外，连接到ether3的网络设备必须支持VLAN标记。

<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container" title="Hint: double-click to select code"><div class="line number1 index0 alt2" data-bidi-marker="true"><code class="ros constants">/interface bridge vlan</code></div><div class="line number2 index1 alt1" data-bidi-marker="true"><code class="ros functions">add </code><code class="ros value">bridge</code><code class="ros plain">=bridge1</code> <code class="ros value">tagged</code><code class="ros plain">=bridge1,ether3</code> <code class="ros value">vlan-ids</code><code class="ros plain">=99</code></div></div></td></tr></tbody></table>
  
![](https://help.mikrotik.com/docs/download/attachments/28606465/Trunk_access_setup_mgmt_access.png?version=2&modificationDate=1618317611046&api=v2)

Management access using tagged traffic through an access port (which makes it a hybrid port)

If PVID for ether1 and bridge1 matches (by default, it does match with 1), then access to the device is allowed using untagged traffic from ether1 because of the feature that dynamically adds untagged ports to the bridge VLAN table.

But you might notice that access using **VLAN99** does not work at this point, this is because you need a VLAN interface that listens for tagged traffic, you can simply create this interface for the appropriate VLAN ID and you can set an IP address for the interface as well:

<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container" title="Hint: double-click to select code"><div class="line number1 index0 alt2" data-bidi-marker="true"><code class="ros constants">/interface vlan</code></div><div class="line number2 index1 alt1" data-bidi-marker="true"><code class="ros functions">add </code><code class="ros value">interface</code><code class="ros plain">=bridge1</code> <code class="ros value">name</code><code class="ros plain">=VLAN99</code> <code class="ros value">vlan-id</code><code class="ros plain">=99</code></div><div class="line number3 index2 alt2" data-bidi-marker="true"><code class="ros constants">/ip address</code></div><div class="line number4 index3 alt1" data-bidi-marker="true"><code class="ros functions">add </code><code class="ros value">address</code><code class="ros plain">=192.168.99.2/24</code> <code class="ros value">interface</code><code class="ros plain">=VLAN99</code></div></div></td></tr></tbody></table>

Our access port (**ether3**) at this point expects tagged and untagged traffic at the same time, such a port is called a **hybrid port**.

At this point, we can benefit from using ingress-filtering and frame-type. First, we are going to focus on frame-type, which limits the allowed packet types (tagged, untagged, both), but in order for frame-type to work properly, ingress-filtering must be enabled, otherwise it will not have any effect. In our example, where we wanted to allow access from **ether3** using tagged traffic (**VLAN99**) and at the same time allow a generic workstation to access the network, we can conclude that this port needs to allow tagged and untagged packets, but **ether1** and **ether2** is supposed to receive only specific types of packets, for this reasons we can enhance our network's security. Since **ether1** is our trunk port, it is only supposed to carry tagged packets, but **ether2** is our access port so it should not carry any tagged packets, based on these conclusions we can drop invalid packets:

<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container" title="Hint: double-click to select code"><div class="line number1 index0 alt2" data-bidi-marker="true"><code class="ros constants">/interface bridge port</code></div><div class="line number2 index1 alt1" data-bidi-marker="true"><code class="ros functions">set </code><code class="ros plain">[</code><code class="ros functions">find </code><code class="ros plain">where </code><code class="ros value">interface</code><code class="ros plain">=ether1]</code> <code class="ros value">ingress-filtering</code><code class="ros plain">=yes</code> <code class="ros value">frame-types</code><code class="ros plain">=admit-only-vlan-tagged</code></div><div class="line number3 index2 alt2" data-bidi-marker="true"><code class="ros functions">set </code><code class="ros plain">[</code><code class="ros functions">find </code><code class="ros plain">where </code><code class="ros value">interface</code><code class="ros plain">=ether2]</code> <code class="ros value">ingress-filtering</code><code class="ros plain">=yes</code> <code class="ros value">frame-types</code><code class="ros plain">=admit-only-untagged-and-priority-tagged</code></div></div></td></tr></tbody></table>

Let's say that you forgot to enable ingress-filtering and change the frame-type property on **ether1**, this would unintentionally add access to the device through **ether1** using untagged traffic since PVID matches for **bridge1** and **ether1**, but you are expecting only tagged traffic to be able to access the device. It is possible to drop all untagged packets that are destined to the **CPU port**:

<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container" title="Hint: double-click to select code"><div class="line number1 index0 alt2" data-bidi-marker="true"><code class="ros constants">/interface bridge</code></div><div class="line number2 index1 alt1" data-bidi-marker="true"><code class="ros functions">set </code><code class="ros plain">bridge1 </code><code class="ros value">frame-types</code><code class="ros plain">=admit-only-vlan-tagged</code> <code class="ros value">ingress-filtering</code><code class="ros plain">=yes</code></div></div></td></tr></tbody></table>

This does not only drop untagged packets, but disables the feature that dynamically adds untagged ports to the bridge VLAN table. If you print out the current bridge VLAN table you would notice that **bridge1** is not dynamically added as an untagged port:

<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container" title="Hint: double-click to select code"><div class="line number1 index0 alt2" data-bidi-marker="true"><code class="text plain">[admin@MikroTik] &gt; /interface bridge vlan print</code></div><div class="line number2 index1 alt1" data-bidi-marker="true"><code class="text plain">Flags: X - disabled, D - dynamic</code></div><div class="line number3 index2 alt2" data-bidi-marker="true"><code class="text spaces">&nbsp;</code><code class="text plain">#&nbsp;&nbsp; BRIDGE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VLAN-IDS&nbsp; CURRENT-TAGGED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CURRENT-UNTAGGED</code></div><div class="line number4 index3 alt1" data-bidi-marker="true"><code class="text spaces">&nbsp;</code><code class="text plain">0&nbsp;&nbsp; bridge1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ether1</code></div><div class="line number5 index4 alt2" data-bidi-marker="true"><code class="text spaces">&nbsp;</code><code class="text plain">1&nbsp;&nbsp; bridge1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ether1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ether3</code></div><div class="line number6 index5 alt1" data-bidi-marker="true"><code class="text spaces">&nbsp;</code><code class="text plain">2 D bridge1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ether1</code></div><div class="line number7 index6 alt2" data-bidi-marker="true"><code class="text spaces">&nbsp;</code><code class="text plain">3&nbsp;&nbsp; bridge1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 99&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bridge1</code></div><div class="line number8 index7 alt1" data-bidi-marker="true"><code class="text spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="text plain">ether3</code></div></div></td></tr></tbody></table>

When `frame-type=admit-only-vlan-tagged` is used on a port, then the port is not dynamically added as an untagged port for the PVID.

While frame-type can be used to drop a certain type of packet, the ingress-filtering can be used to filter out packets before they can be sent out. To fully understand the need for ingress filtering, consider the following scenario: **VLAN99** is allowed on **ether3** and **bridge1**, but you can still send **VLAN99** traffic from **ether1** to **ether3**, this is because the bridge VLAN table checks if a port is allowed to carry a certain VLAN only on egress ports. In our case, **ether3** is allowed to carry **VLAN99** and for this reason, it is forwarded. To prevent this you **MUST** use ingress-filtering. With ingress filtering, ingress packets are also checked, in our case the bridge VLAN table does not contain an entry that **VLAN99** is allowed on **ether1** and therefore will be dropped immediately. Of course, in our scenario without ingress filtering connection cannot be established since **VLAN99** can be forwarded only from **ether1** to **ether3**, but not from **ether3** to **ether1**, though there are still possible attacks that can be used in such a misconfiguration (for example, ARP poisoning). The packet dropping behavior is illustrated in the image below:

![](https://help.mikrotik.com/docs/download/attachments/28606465/Trunk_access_setup_ingress.png?version=2&modificationDate=1618317931543&api=v2)

Trunk/access port setup with and without ingress filtering. Ingress filtering can prevent unwanted traffic from being forwarded. Note that ether1 is not allowed to carry VLAN99 in the bridge VLAN table.

Always try to use ingress-filtering wherever it is possible, it adds a significant layer of security.

The ingress-filtering can be used on the **CPU port** (bridge) as well, this can be used to prevent some possible attack vectors and limit the allowed VLANs that can access the CPU. It is better to drop a packet on an ingress port, rather than on an egress port, this reduces the CPU load, this is quite crucial when you are using hardware offloading with bridge VLAN filtering.

The ingress-filtering property only has an effect on ingress traffic, but frame-type has an effect on egress and ingress traffic.

Even though you can limit the allowed VLANs and packet types on a port, it is never a good security practice to allow access to a device through access ports since an attacker could sniff packets and extract the management VLAN's ID, you should only allow access to the device from the trunk port (**ether1**) since trunk ports usually have better physical security, you should remove the previous entry and allow access to the device through the port that is connected to your router (illustrated in the image below):

<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container" title="Hint: double-click to select code"><div class="line number1 index0 alt2" data-bidi-marker="true"><code class="ros constants">/interface bridge vlan</code></div><div class="line number2 index1 alt1" data-bidi-marker="true"><code class="ros functions">add </code><code class="ros value">bridge</code><code class="ros plain">=bridge1</code> <code class="ros value">tagged</code><code class="ros plain">=bridge1,ether1</code> <code class="ros value">vlan-ids</code><code class="ros plain">=99</code></div></div></td></tr></tbody></table>

![](https://help.mikrotik.com/docs/download/attachments/28606465/Basic_vlan_switching.png?version=3&modificationDate=1618318076269&api=v2)

# VLAN Tunnelling setup

___

In some cases you might want to forward already tagged traffic through certain switches. This is a quite common setup for backbone infrastructures since it provides a possibility encapsulate traffic from, for example, your edge routers and seamlessly forward it over your backbone to another edge router. Below you can find an example of a VLAN tunneling topology:

![](https://help.mikrotik.com/docs/download/attachments/28606465/Provider_bridge.png?version=2&modificationDate=1618318153472&api=v2)

Provider bridge topology

To fully understand how to configure VLAN tunneling properly, you should first read the Trunk/Access port setup section before proceeding any further.

Since RouterOS v6.43 there are two possible ways to achieve this, one is the standardized IEEE 802.1ad way, the other way is using **Tag stacking**, we will first review the standardized way since the same principles apply to both ways and only a couple of parameters must be changed to use the other method. The way VLAN tunneling works is that the bridge checks if the outer VLAN tag is using the same VLAN tag as specified as ether-type. If the VLAN tag matches, the packet is considered as a tagged packet, otherwise it is considered as an untagged packet.

The bridge checks only the outer tag (closest to the MAC address), any other tag is ignored anywhere in a bridge configuration. The bridge is not aware of the packet contents, even though there might be another VLAN tag, only the first VLAN tag is checked.

The ether-type property allows you to select the following EtherTypes for the VLAN tag:

- 0x88a8 - SVID, IEEE 802.1ad, Service VLAN
- 0x8100 - CVID, IEEE 802.1Q, Customer VLAN
- 0x9100 - Double tagged (not very common)

In order to properly configure bridge VLAN filtering, you must understand how does the bridge distinguish between tagged and untagged packets. Like mentioned before, the bridge will check if EtherType matches with the outer VLAN tag in the packet. For example, consider the following packet:

<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container" title="Hint: double-click to select code"><div class="line number1 index0 alt2" data-bidi-marker="true"><code class="text plain">FFFFFFFFFFFF 6C3B6B7C413E 8100 6063 9999</code></div><div class="line number2 index1 alt1" data-bidi-marker="true"><code class="text plain">----------------------------------------</code></div><div class="line number3 index2 alt2" data-bidi-marker="true"><code class="text plain">DST-MAC = FFFFFFFFFFFF</code></div><div class="line number4 index3 alt1" data-bidi-marker="true"><code class="text plain">SRC-MAC = 6C3B6B7C413E</code></div><div class="line number5 index4 alt2" data-bidi-marker="true"><code class="text plain">Outer EtherType = 8100 (IEEE 802.1Q VLAN tag)</code></div><div class="line number6 index5 alt1" data-bidi-marker="true"><code class="text plain">VLAN priority = 6</code></div><div class="line number7 index6 alt2" data-bidi-marker="true"><code class="text plain">VLAN ID = 99 (HEX = 63)</code></div><div class="line number8 index7 alt1" data-bidi-marker="true"><code class="text plain">Inner EtherType = 9999</code></div></div></td></tr></tbody></table>

Let us assume that we have set **`ether-type=0x88a8`**, in this case, the packet above is going to be considered untagged since the bridge is looking for a different VLAN tag. Lets now consider the following packet:

<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container" title="Hint: double-click to select code"><div class="line number1 index0 alt2" data-bidi-marker="true"><code class="text plain">FFFFFFFFFFFF 6C3B6B7C413E 88A8 6063 8100 5062 9999</code></div><div class="line number2 index1 alt1" data-bidi-marker="true"><code class="text plain">----------------------------------------</code></div><div class="line number3 index2 alt2" data-bidi-marker="true"><code class="text plain">DST-MAC = FFFFFFFFFFFF</code></div><div class="line number4 index3 alt1" data-bidi-marker="true"><code class="text plain">SRC-MAC = 6C3B6B7C413E</code></div><div class="line number5 index4 alt2" data-bidi-marker="true"><code class="text plain">Outer EtherType = 88A8 (IEEE 802.1ad VLAN tag)</code></div><div class="line number6 index5 alt1" data-bidi-marker="true"><code class="text plain">VLAN priority = 6</code></div><div class="line number7 index6 alt2" data-bidi-marker="true"><code class="text plain">VLAN ID = 99 (HEX = 63)</code></div><div class="line number8 index7 alt1" data-bidi-marker="true"><code class="text plain">Inner EtherType 1 = 8100 (IEEE 802.1Q VLAN tag)</code></div><div class="line number9 index8 alt2" data-bidi-marker="true"><code class="text plain">VLAN priority = 5</code></div><div class="line number10 index9 alt1" data-bidi-marker="true"><code class="text plain">VLAN ID = 98 (HEX = 62)</code></div><div class="line number11 index10 alt2" data-bidi-marker="true"><code class="text plain">Innter EtherType 2 = 9999</code></div></div></td></tr></tbody></table>

This time let us assume that we have set **`ether-type=0x8100`**, in this case, the packet above is considered as untagged as well since the outer tag is using an IEEE 802.1ad VLAN tag. The same principles apply to other VLAN related functions, for example, the PVID property will add a new VLAN tag on access ports and the VLAN tag will be using the EtherType specified in ether-type.

Both **SW1** and **SW2** are using the same configuration:

<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container" title="Hint: double-click to select code"><div class="line number1 index0 alt2" data-bidi-marker="true"><code class="ros constants">/interface bridge</code></div><div class="line number2 index1 alt1" data-bidi-marker="true"><code class="ros functions">add </code><code class="ros value">name</code><code class="ros plain">=bridge1</code> <code class="ros value">vlan-filtering</code><code class="ros plain">=yes</code> <code class="ros value">ether-type</code><code class="ros plain">=0x88a8</code></div><div class="line number3 index2 alt2" data-bidi-marker="true"><code class="ros constants">/interface bridge port</code></div><div class="line number4 index3 alt1" data-bidi-marker="true"><code class="ros functions">add </code><code class="ros value">interface</code><code class="ros plain">=ether1</code> <code class="ros value">bridge</code><code class="ros plain">=bridge1</code> <code class="ros value">pvid</code><code class="ros plain">=200</code></div><div class="line number5 index4 alt2" data-bidi-marker="true"><code class="ros functions">add </code><code class="ros value">interface</code><code class="ros plain">=ether2</code> <code class="ros value">bridge</code><code class="ros plain">=bridge1</code> <code class="ros value">pvid</code><code class="ros plain">=300</code></div><div class="line number6 index5 alt1" data-bidi-marker="true"><code class="ros functions">add </code><code class="ros value">interface</code><code class="ros plain">=ether3</code> <code class="ros value">bridge</code><code class="ros plain">=bridge1</code></div><div class="line number7 index6 alt2" data-bidi-marker="true"><code class="ros constants">/interface bridge vlan</code></div><div class="line number8 index7 alt1" data-bidi-marker="true"><code class="ros functions">add </code><code class="ros value">bridge</code><code class="ros plain">=bridge1</code> <code class="ros value">tagged</code><code class="ros plain">=ether3</code> <code class="ros value">untagged</code><code class="ros plain">=ether1</code> <code class="ros value">vlan-ids</code><code class="ros plain">=200</code></div><div class="line number9 index8 alt2" data-bidi-marker="true"><code class="ros functions">add </code><code class="ros value">bridge</code><code class="ros plain">=bridge1</code> <code class="ros value">tagged</code><code class="ros plain">=ether3</code> <code class="ros value">untagged</code><code class="ros plain">=ether2</code> <code class="ros value">vlan-ids</code><code class="ros plain">=300</code></div></div></td></tr></tbody></table>

In this example, we are assuming that all routers are passing traffic that is using a CVID VLAN tag (the inner VLAN tag). Such traffic on switches will be considered as untagged traffic based on the principle described above. Switches will encapsulate this traffic using an SVID VLAN tag (the outer VLAN tag) and traffic between **SW1** and **SW2** is going to be considered as tagged. Before traffic reaches its destination, the switches will decapsulate the outer tag and forward the original CVID VLAN tagged frame to routers. See a packet example below:

![](https://help.mikrotik.com/docs/download/attachments/28606465/Service_VLAN_8021ad.png?version=3&modificationDate=1590411291205&api=v2)A packet example before and after SVID VLAN encapsulation 

All principles that apply to the regular trunk/access port setup using IEEE 802.1Q also apply to VLAN tunneling setups, make sure you are limiting VLANs and packet type properly using the bridge VLAN table and ingress filtering.

In case you want to create management access from, let's say, **ether3** to the device and wanted to use **VLAN99**, then you would use such commands:

<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container" title="Hint: double-click to select code"><div class="line number1 index0 alt2" data-bidi-marker="true"><code class="ros constants">/interface bridge vlan</code></div><div class="line number2 index1 alt1" data-bidi-marker="true"><code class="ros functions">add </code><code class="ros value">bridge</code><code class="ros plain">=bridge1</code> <code class="ros value">tagged</code><code class="ros plain">=bridge1,ether3</code> <code class="ros value">vlan-ids</code><code class="ros plain">=99</code></div><div class="line number3 index2 alt2" data-bidi-marker="true"><code class="ros constants">/interface vlan</code></div><div class="line number4 index3 alt1" data-bidi-marker="true"><code class="ros functions">add </code><code class="ros value">interface</code><code class="ros plain">=bridge1</code> <code class="ros value">name</code><code class="ros plain">=VLAN99</code> <code class="ros value">use-service-tag</code><code class="ros plain">=yes</code> <code class="ros value">vlan-id</code><code class="ros plain">=99</code></div><div class="line number5 index4 alt2" data-bidi-marker="true"><code class="ros constants">/ip address</code></div><div class="line number6 index5 alt1" data-bidi-marker="true"><code class="ros functions">add </code><code class="ros value">address</code><code class="ros plain">=192.168.99.2/24</code> <code class="ros value">interface</code><code class="ros plain">=VLAN99</code></div></div></td></tr></tbody></table>

As you may notice, the only difference is that the VLAN interface is using `use-service-tag=yes`, this sets the VLAN interface to listen to SVID (IEEE 802.1ad) VLAN tags. This will require you to use the IEEE 802.1ad VLAN tag to access the device using the management VLAN. This means that you will not be able to connect to the device using a CVID VLAN tag while using bridge VLAN filtering, the ether-type is set globally and will have an effect on all bridge VLAN filtering functions.

Devices with switch chip Marvell-98DX3257 (e.g. CRS354 series) do not support VLAN filtering on 1Gbps Ethernet interfaces for other VLAN types (`0x88a8` and `0x9100`).

## Tag Stacking

In the VLAN Tunnelling setup, we were adding a new VLAN tag that was different from the VLAN tag, but it is possible to add a new VLAN tag regardless of the packet contents. The difference between the regular VLAN tunneling setup is that the bridge does not check if the packet is tagged or untagged, it assumes that all packets that are received on a specific port are all untagged packets and will add a new VLAN tag regardless of whether a VLAN tag is present or not, this is called **Tag Stacking** since it "stacks" VLAN tags on top of the previous tag, regardless of the VLAN tag type. This is a very common setup for networks that do not support the IEEE 802.1ad standard, but still want to encapsulate VLAN traffic into a new VLAN.

The VLAN tag that is going to be added depends on ether-type and PVID. For example, if you have `ether-type=0x8100` and `PVID=200` on a port, then the bridge will add a new IEEE 802.1Q VLAN tag right on top of any other tag (if such are present). The same VLAN filtering principles still apply, you have to determine which ports are going to be your trunk ports and mark them as a tagged port, determine your access ports and add them as untagged ports.

To explain how VLAN tagging and untagging works with tag stacking, let us use the same network topology as before:

![](https://help.mikrotik.com/docs/download/attachments/28606465/Basic_vlan_switching2.png?version=1&modificationDate=1618318089836&api=v2)

What we want to achieve is that regardless of what is being received on **ether2** and **ether3**, a new VLAN tag will be added to encapsulate the traffic that is coming from those ports. What tag-stacking does is forces a new VLAN tag, so we can use this property to achieve our desired setup. We are going to be using the same configuration as in the Trunk/Access port setup, but with tag, stacking enabled on the access ports:

<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container" title="Hint: double-click to select code"><div class="line number1 index0 alt2" data-bidi-marker="true"><code class="ros constants">/interface bridge</code></div><div class="line number2 index1 alt1" data-bidi-marker="true"><code class="ros functions">add </code><code class="ros value">name</code><code class="ros plain">=bridge1</code> <code class="ros value">vlan-filtering</code><code class="ros plain">=yes</code> <code class="ros value">ether-type</code><code class="ros plain">=0x8100</code></div><div class="line number3 index2 alt2" data-bidi-marker="true"><code class="ros constants">/interface bridge port</code></div><div class="line number4 index3 alt1" data-bidi-marker="true"><code class="ros functions">add </code><code class="ros value">bridge</code><code class="ros plain">=bridge1</code> <code class="ros value">interface</code><code class="ros plain">=ether1</code></div><div class="line number5 index4 alt2" data-bidi-marker="true"><code class="ros functions">add </code><code class="ros value">bridge</code><code class="ros plain">=bridge1</code> <code class="ros value">interface</code><code class="ros plain">=ether2</code> <code class="ros value">tag-stacking</code><code class="ros plain">=yes</code> <code class="ros value">pvid</code><code class="ros plain">=20</code></div><div class="line number6 index5 alt1" data-bidi-marker="true"><code class="ros functions">add </code><code class="ros value">bridge</code><code class="ros plain">=bridge1</code> <code class="ros value">interface</code><code class="ros plain">=ether3</code> <code class="ros value">tag-stacking</code><code class="ros plain">=yes</code> <code class="ros value">pvid</code><code class="ros plain">=30</code></div><div class="line number7 index6 alt2" data-bidi-marker="true"><code class="ros constants">/interface bridge vlan</code></div><div class="line number8 index7 alt1" data-bidi-marker="true"><code class="ros functions">add </code><code class="ros value">bridge</code><code class="ros plain">=bridge1</code> <code class="ros value">tagged</code><code class="ros plain">=ether1</code> <code class="ros value">untagged</code><code class="ros plain">=ether2</code> <code class="ros value">vlan-ids</code><code class="ros plain">=20</code></div><div class="line number9 index8 alt2" data-bidi-marker="true"><code class="ros functions">add </code><code class="ros value">bridge</code><code class="ros plain">=bridge1</code> <code class="ros value">tagged</code><code class="ros plain">=ether1</code> <code class="ros value">untagged</code><code class="ros plain">=ether3</code> <code class="ros value">vlan-ids</code><code class="ros plain">=30</code></div></div></td></tr></tbody></table>

The added VLAN tag will use the specified ether-type. The selected EtherType will also be used for VLAN filtering. Only the outer tag is checked, but with tag-stacking in place, the tag checking is skipped and assumes that a new tag must be added either way.

Let us assume that the devices behind **ether2** and **ether3** are sending tagged **VLAN40** traffic. With this configuration, **ALL** packets will get encapsulated with a new VLAN tag, but you must make sure that you have added the VLAN ID from the outer tag to the bridge VLAN table. The **VLAN40** is not added to the bridge VLAN table since it is the inner tag and it is not checked, we are only concerned about the outer tag, which is either **VLAN20** or **VLAN30** depending on the port.

Similar to other setups, the bridge VLAN table is going to be used to determine if the VLAN tag needs to be removed or not. For example, **ether1** receives tagged **VLAN20** packets, the bridge checks that **ether2** is allowed to carry **VLAN20** so it is about to send it out through **ether2**, but it also checks the bridge VLAN table whether the VLAN tag should be removed and since **ether2** is marked as an untagged port, then the bridge will forward these packets from **ether1** to **ether2** without the **VLAN20** VLAN tag.

From the access port perspective, the same principles as in the Trunk/Access port setup apply. All packets that are received on **ether2** will get a new VLAN tag with the VLAN ID that is specified in PVID, in this case, a new VLAN tag will be added with **VLAN20** and this VLAN will be subjected to VLAN filtering. See a packet example below:

![](https://help.mikrotik.com/docs/download/attachments/28606465/Tag_stacking.png?version=2&modificationDate=1590414931104&api=v2)

A packet example before and after tag stacking
